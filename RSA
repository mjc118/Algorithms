import random
import math
import sys

def main():
    print("input length of desired prime")    
    PrimeLength = int(input())
    print("input desired message to be encrypted")
    StrMessage = input()
    q = p = 0 #our prime numbers

    while q == 0 or p == 0 or q == p:
        q = RandomP(PrimeLength)
        p = RandomP(PrimeLength)
    
    n = p * q #our n, used to decode and encode message
    PhiN = (p - 1) * (q - 1)
    
    while True:
        e = RandomP(random.randint(1, len(str(PhiN)) - 1))
        GCD = egcd(e, PhiN)
        if(GCD[0] == 1):
            break

    d = modinv(e, PhiN)
    print("GCD:", egcd(e, PhiN))
    print("q:", q, "p:", p)
    print("n:", n, "PhiN:", PhiN)
    print("e:", e, " d:", d)
    print((e * d) % PhiN)
    encryptedMSG = RSAencrypt(e,n, StrMessage)
    MSGlist = RSAdecrypt(d, n, encryptedMSG)

    for i in reversed(MSGlist):
        sys.stdout.write(i)

    return
    

#Not Used
def modexp(x, y, N):
    if y == 0:
        return 1
    z = modexp(x, math.floor(y / 2), N)
    if y % 2 == 0:
        return ((z **2) % N)
    else:
        return(x * (z **2) % N)

#Euclidean Extended Algorithm to find GCD
def egcd(a, b):
    if a == 0:
        return(b, 0, 1)
    else:
        g, y , x = egcd(b % a, a)
        return(g, x - (b // a) * y, y)

#Modular Multiplicative Inverse
def modinv(a, m):
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None
    else:
        return x % m

def Fermat(Prime):
    a = random.randint(2, Prime - 1)
    #if(modexp(a, Prime - 1, Prime)) == 1:
    if pow(a, Prime - 1, Prime) == 1:
        return True
    else:
        return False

def RandomP(LengthPrime):
    while True:
        Prime = random.randrange(pow(10,LengthPrime - 1) + 1, pow(10,LengthPrime), 2)
        TestsPassed = 0
        for i in range(5):
            if(Fermat(Prime)):
                TestsPassed += 1
            else:
                break
            if TestsPassed >= 5:
              return Prime
 
def RSAencrypt(e, n, message):
    EncrypM = 0
    exponent = len(message) - 1
    incr = 0
    while exponent >= 0:
        EncrypM = EncrypM + (ord(message[incr]) * pow(128, exponent))
        exponent = exponent - 1
        incr = incr + 1

    EncrypM = pow(EncrypM, e, n)
    return EncrypM     

def RSAdecrypt(d, n, message):
    message = pow(message, d, n)
    CharList = []

    while True:
        CharList.append(chr(message % 128))
        message = int(message / 128)
        if(message < 1):
            break

    return CharList

if __name__ == "__main__":
    main()
