import random
import math
import sys

def main():
    print("input length of desired prime")    
    PrimeLength = int(input())
    print("input desired message to be encrypted")
    StrMessage = input()
    q = p = 0 #our prime numbers

    while q == 0 or p == 0 or q == p:
        q = RandomP(PrimeLength)
        p = RandomP(PrimeLength)
    
    n = p * q #our n, used to decode and encode message
    PhiN = (p - 1) * (q - 1)
    
    while True:
        e = RandomP(random.randint(1, len(str(PhiN)) - 1))
        GCD = egcd(e, PhiN)
        if(GCD[0] == 1):
            break

    d = modinv(e, PhiN)
    print("GCD:", egcd(e, PhiN))
    print("q:", q, "p:", p)
    print("n:", n, "PhiN:", PhiN)
    print("e:", e, " d:", d)
    print((e * d) % PhiN)
    encryptedMSG = RSAencrypt(e,n, StrMessage)
    MSGlist = RSAdecrypt(d, n, encryptedMSG)

    for i in MSGlist:
        sys.stdout.write(i)

    print("")

    return

#Python implementation of Euclidean Extended Algorithm to find GCD
def egcd(a, b):
    if a == 0:
        return(b, 0, 1)
    else:
        g, y , x = egcd(b % a, a)
        return(g, x - (b // a) * y, y)

#Python implementation of Modular Multiplicative Inverse
def modinv(a, m):
    gcd, x, y = egcd(a, m)
    if gcd != 1:
        return None
    else:
        return x % m

#Python implementation of Fermat's Theorem
def Fermat(Prime):
    a = random.randint(2, Prime - 1)
    #if(modexp(a, Prime - 1, Prime)) == 1:
    if pow(a, Prime - 1, Prime) == 1:
        return True
    else:
        return False

#choses a random odd number between given range and tests if it is prime using Fermat's Theorem
#(the number must pass Fermat's Test 5 times successively)
def RandomP(LengthPrime):
    while True:
        Prime = random.randrange(pow(10,LengthPrime - 1) + 1, pow(10,LengthPrime), 2)
        TestsPassed = 0
        for i in range(5):
            if(Fermat(Prime)):
                TestsPassed += 1
            else:
                break
            if TestsPassed >= 5:
              return Prime
 
#encrypts our message using method discussed in class
def RSAencrypt(e, n, message):
    EncrypM = ord(message[0])
    for i in range(len(message) - 1):
        EncrypM = 128 * EncrypM + ord(message[i + 1])
    
    EncrypM = pow(EncrypM, e, n)
    return EncrypM     

#decrypts our message using method discussed in class
def RSAdecrypt(d, n, message):
    message = pow(message, d, n)
    CharList = []

    while True:
        CharList.append(chr(message % 128))
        message = int(message / 128)
        if(message < 1):
            break

    CharList.reverse()
    return CharList

if __name__ == "__main__":
    main()
