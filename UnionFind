#include <iostream>
#include <random>
#include <string>
#include <map>
#include <vector>
#include <algorithm>

using namespace std;

//(row * size) + col
int main(){
	vector<int> list, BotRow, TopRow, temp;
	vector<int>ScoreGrid;
	map<int, vector<int>>MyMap;
	bool left, up, Possible = false;
	int Runs, Size, SizeSquared;
	double Probability;

	/*MyMap.insert(pair<int, vector<int>>(111, list));
	MyMap[111].push_back(111);
	temp = MyMap.find(111)->second;
	MyMap.erase(111);*/
	cin >> Runs;
	cin >> Size;
	cin >> Probability;

	SizeSquared = (Size * Size);

	for (int i = 0; i < (SizeSquared); ++i)
		ScoreGrid.push_back(0);

	int** Maze = new int*[Size];
	for (int i = 0; i < Size; ++i)
		Maze[i] = new int[Size];

	for (int r = 0; r < Runs; ++r){
		Possible = false;
		for (int i = 0; i < (SizeSquared); ++i)
			ScoreGrid[i] = 0;

		for (int i = 0; i < Size; ++i){
			for (int j = 0; j < Size; ++j){
				if (((double)rand() / (float)(RAND_MAX)) <= Probability)
					Maze[i][j] = 1;//open
				else
					Maze[i][j] = 0;//closed
			}
		}
		for (int i = 0; i < Size; ++i){
			for (int j = 0; j < Size; ++j){
				cout << Maze[i][j] << " ";
			}
			cout << endl;
		}

		for (int i = 0; i < Size; ++i){
			for (int j = 0; j < Size; ++j){
				left = up = false;
				if ((j - 1) >= 0){
					if (Maze[i][j - 1] == Maze[i][j]){
						MyMap.find(ScoreGrid[(i * Size) + (j - 1)])->second.push_back((i * Size) + j);
						ScoreGrid[(i * Size) + j] = ScoreGrid[(i * Size) + (j - 1)];
						left = true;
					}
				}
				if ((i - 1) >= 0){
					if (Maze[i - 1][j] == Maze[i][j]){
						if (left){
							if (ScoreGrid[((i - 1) * Size) + j] != ScoreGrid[(i * Size) + j]){
								temp = MyMap.find(ScoreGrid[((i - 1) * Size) + j])->second;
								MyMap.erase(ScoreGrid[((i - 1) * Size) + j]);
								for (int it = 0; it < temp.size(); ++it){
									MyMap.find(ScoreGrid[(i * Size) + j])->second.push_back(temp[it]);
									ScoreGrid[temp[it]] = ScoreGrid[(i * Size) + j];
								}
							}
						}
						else{
							MyMap.find(ScoreGrid[((i - 1) * Size) + j])->second.push_back((i * Size) + j);
							ScoreGrid[(i * Size) + j] = ScoreGrid[((i - 1) * Size) + j];
						}
						up = true;
					}
				}
				if (!up && !left){
					MyMap.insert(pair<int, vector<int>>((i * Size) + j, list));
					MyMap[(i * Size) + j].push_back((i * Size) + j);
					ScoreGrid[((i * Size) + j)] = ((i * Size) + j);
				}
			}
		}

		for (int col = 0; col < Size; ++col){//grab all nodes the bottom row is pointing to
			if (Maze[Size - 1][col] == 1)
				BotRow.push_back(ScoreGrid[((Size - 1) * Size) + col]);			
		}
		sort(BotRow.begin(), BotRow.end());
		BotRow.erase(unique(BotRow.begin(), BotRow.end()), BotRow.end());//erases all duplicate values

		for (int col = 0; col < Size; ++col){//grab all nodes the top row is pointing to
			if (Maze[0][col] == 1)
				TopRow.push_back(ScoreGrid[col]);
		}
		sort(TopRow.begin(), TopRow.end());
		TopRow.erase(unique(TopRow.begin(), TopRow.end()), TopRow.end());//erases all duplicate values

		//check to see if any of them are equal, meaning there is a path from the top to the bottom
		for (int i = 0; i < TopRow.size(); ++i){
			for (int j = 0; j < BotRow.size(); ++j){
				if (TopRow[i] == BotRow[j]){
					Possible = true;
					i = TopRow.size();
					break;
				}
			}
		}

		cout << "Possible: " << Possible << " Clusters: " << MyMap.size() << endl << endl;
		MyMap.erase(MyMap.begin(), MyMap.end());
		BotRow.erase(BotRow.begin(), BotRow.end());
		TopRow.erase(TopRow.begin(), TopRow.end());
	}

	ScoreGrid.erase(ScoreGrid.begin(), ScoreGrid.end());
	delete[] Maze;
	return 0;
}
