#include <iostream>
#include <random>
#include <string>
#include <map>
#include <vector>
#include <sstream>
#include <algorithm>
#include <fstream>
#include <math.h>

using namespace std;

//(row * size) + col
int main(int argc, char* argv[]){
	vector<int> list, BotRow, TopRow, temp;
	vector<int>ScoreGrid;
	map<int, vector<int>>MyMap;
	bool left, up, Possible = false;
	int Runs, Size, SizeSquared;
	double Probability;
	if (argc == 2){
		vector<int> input;
		ifstream inputfile(argv[1]);
		int num, incr = 0;
		string line;

		while (getline(inputfile, line)){
			stringstream ss(line);
			while (ss >> num){
				input.push_back(num);
			}
		}
		inputfile.close();
		Size = sqrt(input.size());
		SizeSquared = (Size * Size);

		for (int i = 0; i < (SizeSquared); ++i)
			ScoreGrid.push_back(0);

		int** Maze = new int*[Size];
		for (int i = 0; i < Size; ++i)
			Maze[i] = new int[Size];

		for (int i = 0; i < (SizeSquared); ++i)
			ScoreGrid[i] = 0;

		for (int i = 0; i < Size; ++i){
			for (int j = 0; j < Size; ++j){
				Maze[i][j] = input[incr];
				++incr;
			}
		}

		for (int i = 0; i < Size; ++i){
			for (int j = 0; j < Size; ++j){
				cout << Maze[i][j] << " ";
			}
			cout << endl;
		}

		for (int i = 0; i < Size; ++i){
			for (int j = 0; j < Size; ++j){
				left = up = false;
				if ((j - 1) >= 0){
					if (Maze[i][j - 1] == Maze[i][j]){
						MyMap.find(ScoreGrid[(i * Size) + (j - 1)])->second.push_back((i * Size) + j);
						ScoreGrid[(i * Size) + j] = ScoreGrid[(i * Size) + (j - 1)];
						left = true;
					}
				}
				if ((i - 1) >= 0){
					if (Maze[i - 1][j] == Maze[i][j]){
						if (left){
							if (ScoreGrid[((i - 1) * Size) + j] != ScoreGrid[(i * Size) + j]){
								temp = MyMap.find(ScoreGrid[((i - 1) * Size) + j])->second;
								MyMap.erase(ScoreGrid[((i - 1) * Size) + j]);
								for (int it = 0; it < temp.size(); ++it){
									MyMap.find(ScoreGrid[(i * Size) + j])->second.push_back(temp[it]);
									ScoreGrid[temp[it]] = ScoreGrid[(i * Size) + j];
								}
							}
						}
						else{
							MyMap.find(ScoreGrid[((i - 1) * Size) + j])->second.push_back((i * Size) + j);
							ScoreGrid[(i * Size) + j] = ScoreGrid[((i - 1) * Size) + j];
						}
						up = true;
					}
				}
				if (!up && !left){
					MyMap.insert(pair<int, vector<int>>((i * Size) + j, list));
					MyMap[(i * Size) + j].push_back((i * Size) + j);
					ScoreGrid[((i * Size) + j)] = ((i * Size) + j);
				}
			}
		}

		for (int col = 0; col < Size; ++col){//grab all nodes the bottom row is pointing to
			if (Maze[Size - 1][col] == 1)
				BotRow.push_back(ScoreGrid[((Size - 1) * Size) + col]);
		}
		sort(BotRow.begin(), BotRow.end());
		BotRow.erase(unique(BotRow.begin(), BotRow.end()), BotRow.end());//erases all duplicate values

		for (int col = 0; col < Size; ++col){//grab all nodes the top row is pointing to
			if (Maze[0][col] == 1)
				TopRow.push_back(ScoreGrid[col]);
		}
		sort(TopRow.begin(), TopRow.end());
		TopRow.erase(unique(TopRow.begin(), TopRow.end()), TopRow.end());//erases all duplicate values

		//check to see if any of them are equal, meaning there is a path from the top to the bottom
		for (int i = 0; i < TopRow.size(); ++i){
			for (int j = 0; j < BotRow.size(); ++j){
				if (TopRow[i] == BotRow[j]){
					Possible = true;
					i = TopRow.size();
					break;
				}
			}
		}

		cout << "Possible: " << Possible << " Clusters: " << MyMap.size() << endl << endl;
		MyMap.erase(MyMap.begin(), MyMap.end());
		BotRow.erase(BotRow.begin(), BotRow.end());
		TopRow.erase(TopRow.begin(), TopRow.end());


		ScoreGrid.erase(ScoreGrid.begin(), ScoreGrid.end());
		delete[] Maze;
	}
	else if (argc == 4){
		Probability = stod(argv[1]);
		Runs = atoi(argv[2]);
		Size = atoi(argv[3]);

		SizeSquared = (Size * Size);

		for (int i = 0; i < (SizeSquared); ++i)
			ScoreGrid.push_back(0);

		int** Maze = new int*[Size];
		for (int i = 0; i < Size; ++i)
			Maze[i] = new int[Size];

		for (int r = 0; r < Runs; ++r){
			Possible = false;
			for (int i = 0; i < (SizeSquared); ++i)
				ScoreGrid[i] = 0;

			for (int i = 0; i < Size; ++i){
				for (int j = 0; j < Size; ++j){
					if (((double)rand() / (float)(RAND_MAX)) <= Probability)
						Maze[i][j] = 1;//open
					else
						Maze[i][j] = 0;//closed
				}
			}
			for (int i = 0; i < Size; ++i){
				for (int j = 0; j < Size; ++j){
					cout << Maze[i][j] << " ";
				}
				cout << endl;
			}

			for (int i = 0; i < Size; ++i){
				for (int j = 0; j < Size; ++j){
					left = up = false;
					if ((j - 1) >= 0){
						if (Maze[i][j - 1] == Maze[i][j]){
							MyMap.find(ScoreGrid[(i * Size) + (j - 1)])->second.push_back((i * Size) + j);
							ScoreGrid[(i * Size) + j] = ScoreGrid[(i * Size) + (j - 1)];
							left = true;
						}
					}
					if ((i - 1) >= 0){
						if (Maze[i - 1][j] == Maze[i][j]){
							if (left){
								if (ScoreGrid[((i - 1) * Size) + j] != ScoreGrid[(i * Size) + j]){
									temp = MyMap.find(ScoreGrid[((i - 1) * Size) + j])->second;
									MyMap.erase(ScoreGrid[((i - 1) * Size) + j]);
									for (int it = 0; it < temp.size(); ++it){
										MyMap.find(ScoreGrid[(i * Size) + j])->second.push_back(temp[it]);
										ScoreGrid[temp[it]] = ScoreGrid[(i * Size) + j];
									}
								}
							}
							else{
								MyMap.find(ScoreGrid[((i - 1) * Size) + j])->second.push_back((i * Size) + j);
								ScoreGrid[(i * Size) + j] = ScoreGrid[((i - 1) * Size) + j];
							}
							up = true;
						}
					}
					if (!up && !left){
						MyMap.insert(pair<int, vector<int>>((i * Size) + j, list));
						MyMap[(i * Size) + j].push_back((i * Size) + j);
						ScoreGrid[((i * Size) + j)] = ((i * Size) + j);
					}
				}
			}

			for (int col = 0; col < Size; ++col){//grab all nodes the bottom row is pointing to
				if (Maze[Size - 1][col] == 1)
					BotRow.push_back(ScoreGrid[((Size - 1) * Size) + col]);
			}
			sort(BotRow.begin(), BotRow.end());
			BotRow.erase(unique(BotRow.begin(), BotRow.end()), BotRow.end());//erases all duplicate values

			for (int col = 0; col < Size; ++col){//grab all nodes the top row is pointing to
				if (Maze[0][col] == 1)
					TopRow.push_back(ScoreGrid[col]);
			}
			sort(TopRow.begin(), TopRow.end());
			TopRow.erase(unique(TopRow.begin(), TopRow.end()), TopRow.end());//erases all duplicate values

			//check to see if any of them are equal, meaning there is a path from the top to the bottom
			for (int i = 0; i < TopRow.size(); ++i){
				for (int j = 0; j < BotRow.size(); ++j){
					if (TopRow[i] == BotRow[j]){
						Possible = true;
						i = TopRow.size();
						break;
					}
				}
			}

			cout << "Possible: " << Possible << " Clusters: " << MyMap.size() << endl << endl;
			MyMap.erase(MyMap.begin(), MyMap.end());
			BotRow.erase(BotRow.begin(), BotRow.end());
			TopRow.erase(TopRow.begin(), TopRow.end());
		}

		ScoreGrid.erase(ScoreGrid.begin(), ScoreGrid.end());
		delete[] Maze;
	}
	return 0;
}
